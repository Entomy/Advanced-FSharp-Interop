<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Advanced F# Interop</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link rel="stylesheet" href="stylesheet.css" />
		<link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
		<link rel="icon" href="favicon.ico" type="image/x-icon">
		<script src="microlight.js"></script>
	</head>
	<body>
		<article>
			<h1 class="title">Advanced F# Interop</h1>
			<p>You like F#. I like F#. I also like C# and even when I have control over both ecosystems, getting the two to play nice with each other isn't the easiest of things. Even worse is when you <em>need</em> to use code written by someone that... oh my god, where did they learn to program? Look, we've all been there. Some API's just feel awful, especially when consuming in F#.</p>
			<p>So how do you deal with it? For many people they write their own replacement in F#.</p>
			<img alt="Meme: Stop right there criminal scum" src="" />
			<p>There's a better way. And it doesn't actually require that much work.</p>
			<aside>
				<p>I've written this mostly in hopes that library authors use this information to provide better F# support when possible, and to help the community to provide better F# support when not.</p>
			</aside>
			<h2>Example Library</h2>
			<p>For the sake of this article I've written every F# programmers worst nightmare: The most extremely imperative and procedural and impure library I could come up with. And you don't have a choice in using something else because your manager is an idiot or something. The library is simple: a single specialized stack type for <a href="https://docs.microsoft.com/en-us/dotnet/api/system.double">Double</a>.</p>
			<p>Normally people assume that if they mark the assembly <a href="https://docs.microsoft.com/en-us/dotnet/api/system.clscompliantattribute">CLSCompliant</a> then everything is great and every language can consume the API. This is half true. Everything <em>can</em> consume the API. I'm pretty sure everything can also eat dirt, but that doesn't mean you or I want to. I marked the example library <a href="https://docs.microsoft.com/en-us/dotnet/api/system.clscompliantattribute">CLSCompliant</a>, but it's bad. I died inside writing it.</p>
			<p>Let's have a look at the API.</p>
<pre>
<code>void Add();</code>
<code>void Add(out Double result);</code>
<code>void Subtract();</code>
<code>void Subtract(out Double result);</code>
<code>void Multiply();</code>
<code>void Multiply(out Double result);</code>
<code>void Divide();</code>
<code>void Divide(out Double result);</code>
<code>//... As well as everything Stack&lt;Double&gt; would already have</code>
</pre>
			<p>Let's have a look at just how bad this is, using the stack API for the arithmetic 3 * 5 - 8.</p>
<pre>
<code>let stack = DoubleStack()</code>
<code>stack.Push(3.0)</code>
<code>stack.Push(5.0)</code>
<code>stack.Multiply()</code>
<code>stack.Push(8.0)</code>
<code>stack.Subtract()</code>
</pre>
			<p>So, that's not great. It works, and it's identical across languages. But man that's not the kind of API we want to be working with in F#. But what about those other methods, the ones with the <code>out</code> parameters?</p>
<pre>
<code>let stack = DoubleStack()</code>
<code>let mutable result = ref 0.0</code>
<code>stack.Push(3.0)</code>
<code>stack.Push(5.0)</code>
<code>stack.Multiply(result)</code>
</pre>
			<p>You see why I say I died inside. Surely there's no hope here. Surely this is so far-gone that you either suck it up and use it as is, or write your own with a F# friendly API.</p>
			<img alt="Meme: Trump saying wrong" src="" />
			<p>Over the course of this article I'll show you how to turn this into a very function feeling API you'd be certain was written natively in F#.</p>
			<h2>Functional Push/Pop/Peek</h2>
			<p>I think a good starting point is to make <code>Push()</code>, <code>Pop()</code>, and <code>Peek()</code> feel functional, by implementing our own <em>stack pipeline</em>.</p>
<pre>
<code>let ( |=&gt; )(stack:DoubleStack)(value) = stack.Push(value)</code>
<code>let stack = DoubleStack() |=&gt; 5.0</code>
</pre>
			<p>And just like that we have a working pipeline! Right? No. We do have a working single operation, but this leaves us with the same situation, in a different coat of paint. Try actually chaining the pipeline and you'll see the issue. We need to return the stack in the function call.</p>
<pre>
<code>let ( |=&gt; )(stack:DoubleStack)(value) =</code>
<code>	stack.Push(value)</code>
<code>	stack</code>
<code>let stack = DoubleStack() |=&gt; 5.0 |=&gt; 3.0</code>
<code>stack.Multiply()</code>
<code>Assert.Equal(15.0, stack.Peek())</code>
</pre>
			<p>That's already looking a good amount better. Still a ways to go though. Let's take care of the other two methods we mentioned</p>
<pre>
<code>let inline pop (stack:DoubleStack) = stack.Pop()</code>
<code>let inline peek (stack:DoubleStack) = stack.Peek()</code>
</pre>
			<p>This are very straightforward translations. So straightforward that they are inlined. These kind of methods are the easiest to bind, and are something you should already be familiar with. With all these combined, we're now left with something that's starting to look functional, but is still obviously not there yet.</p>
<pre>
<code>let stack = DoubleStack() |=&gt; 5.0 |=&gt; 3.0</code>
<code>stack.Multiply()</code>
<code>Assert.Equal(15.0, peek stack)</code>
</pre>
			<h2>Functional Object Initializer</h2>
			<p>This is a <em>deep</em> one, because while it's not that big of an issue, it's not easy to solve. You can still deal with things though. See, that <code>DoubleStack()</code> at the beginning of the pipeline when declaring is a bit annoying. Not the end of the world, but we can do better.</p>
<pre>
<code>type Pipeline =</code>
<code>	static member Pipe(left:DoubleStack, right:float) =</code>
<code>		left.Push(right)</code>
<code>		left</code>
<code>	static member Pipe(left:float, right:float) =</code>
<code>		let result = DoubleStack()</code>
<code>		result.Push(left)</code>
<code>		result.Push(right)</code>
<code>		result</code>
<code></code>
<code>let inline private pipe&lt; ^t, ^a when (^t or ^a) : (static member Pipe : ^a * float -> DoubleStack)&gt; left right =</code>
<code>	((^t or ^a) : (static member Pipe : ^a * float -> DoubleStack)(left, right))</code>
<code></code>
<code>let inline ( |=&gt; )(left:^a)(right:float) = pipe&lt;Pipeline, ^a> left right</code>
</pre>
			<p>What in the heck is this? I promise this isn't some fancy black magic. Let's go over it one thing at a time.</p>
			<p>First is the Pipeline type we defined. This <em>must</em> has the same visibility as the function or operator which will be using it. In it we're defining overloads of <code>Pipe()</code> which is static. You can define whatever you want here; these are the actual methods that are being called. The first one does what we already defined: it takes a stack and a float, pushes the float onto the stack, and returns the stack. The second one adds the behavior we wanted: it creates a stack, pushes the left value onto it, then pushes the right value onto it, then returns the stack.</p>
			<p>Second is some inline and generic trickery which is probably the most intimidating thing to those not familiar with F#'s type system. It's not that bad, I promise. Ignoring the generic part, we have a function called pipe with two curried parameters: left and right. Not so bad. The generic part says that we're considering two statically resolved types: <code>^t</code> and <code>^a</code>. That static resolution is important, and because of that, this function absolutely must be inlined. It doesn't need to be visible however, so I've taken to making it private, always. The rest of the generic says that on <code>^t</code> or <code>^a</code>, there will be a static member <code>Pipe</code> with the signature <code>^a * float -> DoubleStack</code>. Look at those methods we were just talking about. As long as <code>^a</code> matches one of their first parameters, we have a matching method. The seemingly repeating code in the definition part of this function just says to call whatever method this resolves to, with the tupled arguments <code>(left, right)</code>. There, that wasn't too bad. I'll admit even I still kinda think it's black magic though.</p>
			<p>The third part is just a slight modification to our original stack pipeline operator. This also needs to be inlined now. Inlining both of these functions is extremely important. Similarly, we can change the lefthand parameter to be of <code>^a</code>, so that it statically resolves. Then we call the black magic function instead of what we were doing. This is where <code>^t</code> and <code>Pipeline</code> comes into play. Assuming the library we're working with is third party, we can't add an instance member called Pipe to it. And we definitely can't add an instance member to <code>Double</code>! This additional parameter is for a type we've defined that will also have these methods, which is why it was declared as <code>static member</code> in the generic. Now it knows to look inside of our own type as well.</p>
			<p>How much progress did this make?</p>
<pre>
<code>let stack = 5.0 |=&gt; 3.0</code>
<code>stack.Multiply()</code>
<code>Assert.Equal(15.0, peek stack)</code>
</pre>
			<p>Not a whole lot has changed, but it certainly looks cleaner. Try out longer pipelines, it still works.</p>
			<aside>
				<p>There is another, <a href="http://www.fssnip.net/7Xj">simpler way</a>, to accomplish this. Use it when you can, but from my experience it's not possible in many situations, while this approach is.</p>
				<p>I've found this is most useful when mapping overridden methods to functions so that currying and pipelining is possible. So this often means rearranging parameters. You may find other uses. I don't recommend doing this just because you can.</p>
			</aside>
			<h2>Functional Stack Arithmetic</h2>
			<p>The last remaining thing is those pesky arithmetic methods. Surely by now we've finally run into something we can't fully bind to this functional, pipeline heavy, environment. Right?</p>
			<p>Actually this one is really easy, with what we've already set up</p>
<pre>
<code>let add (stack:DoubleStack) =</code>
<code>	stack.Add()</code>
<code>	stack</code>
</pre>
			<p>And so on. That's it. No seriously, that's it. Because of the stack pipeline operators exact symbol (<code>|=></code>) not only does it render like a pipe arrow thing when using <a href="https://github.com/tonsky/FiraCode">Fira Code</a> or related fonts, but it also has the exact same precedence and associativity as the function pipeline operator, so there's nothing new to add.</p>
			<p>Putting everything together we have:</p>
<pre>
<code>let stack = 3.0 |=> 5.0 |> mul |=> 8.0 |> sub</code>
<code>Assert.Equal(7.0, peek stack)</code>
</pre>
			<p>I told you it was possible. 😉</p>
			<p>There's a lot more, but this article has covered a lot and I don't want to provide an overwhelming amount of information. So expect more in the future.</p>
		</article>
		<footer>
			Copyright 2019 - Patrick Kelly - <a href="https://github.com/entomy/entomy.github.io">site repo</a>
		</footer>		
	</body>
</html>